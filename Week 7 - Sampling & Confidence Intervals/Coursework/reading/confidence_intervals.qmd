---
title: "Week 7 -- Confidence Intervals for the Slope"
format: 
  html:
    self-contained: true
    table-of-contents: true
    number-sections: true
    number-depth: 3
editor: visual
bibliography: references.bib
execute: 
  echo: false
  message: false
  warning: false
resources: 
  - reading_guide/week7_reading_guide_CI.docx
  - reading_guide/week7_reading_guide_CI.html
---

```{r set-up}
#| include: false

library(tidyverse)
library(openintro)
library(moderndive)
library(infer)

# Set output digit precision
options(scipen = 999) # , digits = 4)
set.seed(1234)

p_red <- bowl %>%
  summarize(mean(color == "red")) %>%
  pull()
n_balls_sample <- 50L

births14 <- births14 |> 
  mutate(ID = 1:n()) |> 
  relocate(ID, mage, weight)
```

This week's reading is a compilation of [Chapter 8](https://moderndive.com/8-confidence-intervals.html) from *ModernDive* [@kim2020], [Chapter 24](openintro-ims.netlify.app/inf-model-slr.html) from *Introduction to Modern Statistics* [@ims], with a smattering of my own ideas.

### Reading Guide

Download the reading guide as a [Word Document here](reading_guide/week7_reading_guide_CI.docx)

Download the reading guide as an [HTML file here](reading_guide/week7_reading_guide_CI.html)

### Sampling Review

In the last reading, we studied the concept of sampling variation. Using the example of estimating the proportion of red balls in a bowl, we started with a "tactile" exercise where a shovel was used to draw a sample of balls from the bowl. While we could have performed an exhaustive count of **all** the balls in the bowl, this would have been a tedious process. So instead, we used a shovel to extract a sample of balls and used the resulting proportion that were red as an *estimate*. Furthermore, we made sure to mix the bowl's contents before every use of the shovel. Because of the randomness created by the mixing, different uses of the shovel yielded different proportions red and hence different estimates of the proportion of the bowl's balls that are red.

We then used R to mimic this "tactile" sampling process. Using our computer's random number generator, we were able to quickly mimic the tactile sampling procedure a large number of times. Moreover, we were able to explore how different our results would be if we used different sized shovels, with 25, 50, and 100 slots. When we visualized the results of these three different shovel sizes, we saw that as the sample size increased, the variation in the estimates ($\widehat{p}$) decreased.

These visualizations of the repeated sampling from the bowl have a special name in Statistics -- a *sampling distribution*. These distributions all us to study how our estimates (\$\widehat{p}) varied from one sample to another; in other words, we wanted to study the effect of *sampling variation*. Once we had over 1,000 different estimates, we quantified the variation of these estimates using their standard deviation, which also has a special name in Statistics -- the *standard error*. Visually we saw the spread of the sampling distributions get narrower as the sample size increased, which was reiterated by the standard errors -- the standard errors decreased as the sample size increased. This decrease in spread of the sampling distribution gives us more *precise* estimates that varied less around the center.

We then tied these sampling concepts to the statistical terminology and mathematical notation related to sampling. Our *study population* was the large bowl with $N$ = `r nrow(bowl)` balls, while the *population parameter*, the unknown quantity of interest, was the population proportion $p$ of the bowl's balls that were red. Since performing a *census* would be expensive in terms of time and energy, we instead extracted a *sample* of size $n$ = 50. The *point estimate*, also known as a *sample statistic*, used to estimate $p$ was the sample proportion $\widehat{p}$ of these 50 sampled balls that were red. Furthermore, since the sample was obtained at *random*, it can be considered as *unbiased* and *representative* of the population. Thus any results based on the sample could be *generalized* to the population. Therefore, the proportion of the shovel's balls that were red was a "good guess" of the proportion of the bowl's balls that are red. In other words, we used the sample to *infer* about the population.

However, we acknowledged that both the tactile and virtual sampling exercises are not what one would do in real life; this was merely an activity used to study the effects of sampling variation. In a real-life situation, we would not take 1,000s of samples of size $n$, but rather take a *single* representative sample that's as large as possible. Additionally, we knew that the true proportion of the bowl's balls that were red was `r p_red*100`%. In a real-life situation, we will not know what this value is. Because if we did, then why would we take a sample to estimate it?

So how does one quantify the effects of sampling variation when you only have a *single sample* to work with? You cannot directly study the effects of sampling variation when you only have one sample. One common method to study this is *bootstrapping resampling*, which will be the focus of the earlier sections of this reading.

Furthermore, what if we would like not only a single estimate of the unknown population parameter, but also a *range of highly plausible* values? For example, when you read about political polls, they tell you the percent of all Californians who support a specific measure, but in addition to this estimate they provide the poll's "margin of error". This margin of error can be used to construct a range of plausible values for the true percentage of people who support a specific measure. This range of plausible values is what's known as a *confidence interval*, which will be the focus of the later sections of this reading.


## Baby Birth Weights

Medical researchers may be interested in the relationship between baby birth weight and the age of the mother, so as to provide medical interventions for specific age groups if it is found that they are associated with lower birth weights. 

Every year, the US releases to the public a large data set containing information on births recorded in the country. The `births14`[http://openintrostat.github.io/openintro/reference/births14.html] dataset is a random sample of 1,000 cases from  one such dataset released in 2014.

### Observed data

@fig-births-slr visualizes the relationship between `mage` and `weight` for this sample of 1,000 birth records.  

```{r births-slr-plot}
#| label: fig-births-slr
#| fig-cap: "Weight of baby at birth (in lbs) as explained by mother's age."
#| echo: true
#| 

ggplot(data = births14, 
       mapping = aes(x = mage, y = weight)) + 
  geom_point() + 
  geom_smooth(method = "lm") +
  labs(x = "Mother's Age", 
       y = "Birth Weight of Baby (lbs)")
```

@tbl-births-slr displays the estimated regression coefficients for modeling the relationship between `mage` and `weight` for this sample of 1,000 birth records. 

```{r births-slr-code}
#| echo: true
#| eval: false

births_lm <- lm(weight ~ mage, data = births14)

get_regression_table(births_lm)
```

```{r}
#| label: tbl-births-slr
#| tbl-cap: "The least squares estimates of the intercept and slope for modeling the relationship between birth weight and mother's age."

births_lm <- lm(weight ~ mage, data = births14)

births_table <- get_regression_table(births_lm) 

births_table |> 
  knitr::kable() |> 
  kableExtra::kable_styling()

```


Based on these coefficients, the estimated regression equation is:

$$ \widehat{\text{birth weight}} = -3.598 + 0.279 \times \text{weeks of pregnancy}$$

::: {.callout-note}
We will let $\beta_1$ represent the slope of the relationship between baby birth weight and mother's age for **every** baby born in the US in 2014. We will estimate $\beta_1$ using the `births14` dataset, labeling the estimate $b_1$ (just as we did in Week 4). 
:::

::: {.callout-caution}
A **parameter** is the value of the statistic of interest for the entire **population**. 

We typically estimate the parameter using a "point estimate" from a sample of data. The point estimate is also referred to as the **statistic**. 
:::

### Variability of the statistic

This sample of 1,000 births is only one of possibly tens of thousands of possible samples that could have been taken from the large dataset released in 2014. So, then we might wonder how different our regression equation would be if we had a different sample. There is no reason to believe that $\beta_1$ is 0.279, but there is also no reason to believe that $\beta_1$ is particularly far away from $b_1 =$ 0.279. 

Just this week you read about how estimates, such as $b_1$, are prone to sampling variation -- the variability from sample to sample. For example, if we took a different sample of 1,000 births, would we obtain a slope of exactly 0.279? No, that seems fairly unlikely. We might obtain a slope of 0.29 or 0.26, or even 0.35! 

When we studied the effects of sampling variation, we took many samples, something that was easily done with a shovel and a bowl of red and white balls. In this case, however, how would we obtain another sample? Well, we would need to go to the source of the data---the large public dataset released in 2014---and take another random sample of 1,000 observations. Maybe we don't have access to that original dataset of 2014 births, how could we study the effects of sampling variation using our single sample? We will do so using a technique known as **bootstrap resampling with replacement**, which we now illustrate.

### Resampling once

![Step 1: Write out mother's ages and birth weights on 1,000 slips of paper representing one of the 1,000 births included in the original sample. ](images/baby-postit.jpg){#fig-baby-post-it}

**Step 1**: Print out 1,000 identically sized slips of paper (or post-it notes) representing the sample of 1,000 babies in our sample. On each piece of paper, write the mother's age and the birth weight of the baby. @fig-baby-post-it displays six of these such papers.  

**Step 2**: Put the 1,000 slips of paper into a hat as seen in @fig-hat. 

![Step 2: Putting 1,000 slips of paper (post-its) in a hat.](images/hat.JPG){#fig-hat}

**Step 3**: Mix the hat's contents and draw one slip of paper at random, as seen in @fig-draw-out. Record the mother's age and birth weight, as printed on the paper. 

![Step 3: Drawing one slip of paper at random.](images/draw-out2.jpg){#fig-draw-out}

**Step 4**: Put the slip of paper back in the hat! In other words, replace it as seen in @fig-put-back. 

![Step 4: Replacing slip of paper.](images/put-back.jpg){#fig-put-back}

**Step 5**: Repeat Steps 3 and 4 a total of 999 more times, resulting in 1,000 recorded mother's ages and baby birth weights. 

What we just performed was a *resampling* of the original sample of 1,000 birth weights. We **are not** sampling 1,000 birth weights from the population of all 2014 US births as we did for our original sample. Instead, we are mimicking this process by resampling 1,000 birth weights from our original sample.

Now ask yourselves, why did we replace our resampled slip of paper back into the hat in Step 4? Because if we left the slip of paper out of the hat each time we performed Step 4, we would end up with the **same** 1,000 birth weights! In other words, replacing the slips of paper induces *sampling variation*.

Being more precise with our terminology, we just performed a *resampling with replacement* from the original sample of 1,000 birth weights. Had we left the slip of paper out of the hat each time we performed Step 4, this would be *resampling without replacement*.

Let's study our sample of 1,000 resampled birth weights and mother's ages. First, I've made a table of the number of times each observation (birth record) was resampled. @tbl-resample-id displays the birth records that were resampled the most often. Based on the table, it appears that record IDs 71 and 534 were resampled six times. 

```{r births-resample}
#| label: tbl-resample-id
#| tbl-cap: "Frequencies of how often a given birth record (ID) was resampled." 

resample1<- births14 |> 
  mutate(ID = 1:n()) |> 
  relocate(ID) |> 
  rep_sample_n(size = 1000, replace = TRUE) |> 
  ungroup()

resample1 |> 
  count(ID) |> 
  slice_max(order_by = n, n = 10) |>  
  pivot_wider(names_from = ID, values_from = n) |> 
  knitr::kable() |> 
  kableExtra::kable_styling()

```
::: {.callout-tip}
# Remember 

When sampling with replacement, not every observation is guaranteed to be sampled. So, some observations from the original sample may never appear in the resample, whereas others may appear multiple times. 
:::

@fig-compare-dist compares the relationship between mother's age and baby birth weight from our resample with the relationship in our original sample. 

```{r}
#| echo: true
#| label: fig-compare-dist
#| fig-cap: "Comparing relationship between `mage` and `weight` in the resampled birth records compared to the relationship seen in the original sample of birth records."
#| fig-subcap:
#|   - "Original Sample of 1,000 Birth Records"
#|   - "Resample of 1,000 Birth Records"
#| layout-nrow: 1

ggplot(data = births14, 
       mapping = aes(x = mage, y = weight)) + 
  geom_point() + 
  geom_smooth(method = "lm") +
  labs(x = "Mother's Age", 
       y = "Birth Weight (lbs)")

ggplot(data = resample1, 
       mapping = aes(x = mage, y = weight)) + 
  geom_point() + 
  geom_smooth(method = "lm") +
  labs(x = "Mother's Age", 
       y = "Birth Weight (lbs)")

```

Observed in @fig-compare-dist that while the general shape of both relationships are similar, they are not identical. 

Recall, from the previous section that the sample slope ($b_1$) from the original sample was `r filter(births_table, term == "weeks")$estimate`. What about for our resample? Based on the scatterplot, what would your guess be? Larger than before? Smaller than before?

Let's look at the coefficient estimates for the resampled dataset. @tbl-births-resample displays the estimated regression coefficients for modeling the relationship between `mage` and `weight` for the resample of 1,000 birth records. 

```{r births-resample-code}
#| echo: true
#| eval: false

resample_lm <- lm(weight ~ mage, data = resample1)

get_regression_table(resample_lm)
```

```{r}
#| label: tbl-births-resample
#| tbl-cap: "The least squares estimates of the intercept and slope for modeling the relationship between birth weight and mother's age, for the *resample* of 1,000 birth records."

resample_lm <- lm(weight ~ mage, data = resample1)

resample_table <- get_regression_table(resample_lm)

resample_table |> 
  knitr::kable() |> 
  kableExtra::kable_styling()

```

For the resampled dataset, the relationship between mother's age and baby birth weight is much weaker than in the original sample, with an estimated slope of $b_1 =$ `r filter(resample_table, term == "mage")$estimate`. 

What if we repeated this resampling exercise many times? Would we obtain the same slope each time? In other words, would our guess at the slope for the relationship between mother's age and birth weight for all births in the US in 2014 exactly `r filter(resample_table, term == "mage")$estimate` every time? 

## Computer simulation and resampling

It should be very clear that tactile resampling with a dataset with 1,000 observations would be extremely time consuming, nothing we would want to ask our friends to do. A computer, however, would be happy to do this process for us! 

### Virtually resampling once

First, let’s perform the virtual analog of resampling once. Recall that the `births14` dataset included in the **openintro** package contains the 1,000 birth records from the original study. Furthermore, recall in the last chapter that we used the `rep_sample_n()` function as a virtual shovel to sample balls from our virtual bowl of 2400 balls as follows:

```{r}
virtual_shovel <- rep_sample_n(bowl, 
                               size = 50, 
                               replace = FALSE, 
                               reps = 1)

```

Let’s modify this code to perform the resampling *with replacement* from the 1,000 birth records in the original sample:

```{r virtual-sample-code}
#| echo: true
virtual_resample <- rep_sample_n(births14, 
                                 size = 1000,
                                 replace = TRUE, 
                                 reps = 1)

```

Observe how we explicitly set the `replace` argument to `TRUE` in order to tell `rep_sample_n()` that we would like to sample birth records *with replacement*. Had we not kept `replace = FALSE`, we would have done resampling *without replacement*. Additionally, we changed the sample `size`, as we need to create a sample with the *same* size as the original sample which had 1,000 observations. 

Let’s look at only the first 10 out of 1,000 rows of `virtual_resample`:

```{r virtual-resample-preview}
#| echo: true
virtual_resample
```

The `replicate` variable only takes on the value of 1 corresponding to us only having `reps = 1`, the `ID` variable indicates which of the 1,000 birth records was resampled, and `mage` and `weight` denote mother's age and the baby's birth weight, respectively. 

Let’s now compute the slope for the relationship between mother's age and baby's birth weight for this resample:

```{r virtual-resample-lm}
#| echo: true
#| eval: false
virtual_resample_lm <- lm(weight ~ mage, data = virtual_resample)

get_regression_table(virtual_resample_lm)
```

```{r virtual-resample-lm-table}
#| label: tbl-virtual-resample-lm
#| tbl-cap: "The least squares estimates of the intercept and slope for modeling the relationship between birth weight and mother's age, for the virtual resample of 1,000 birth records."

virtual_resample_lm <- lm(weight ~ mage, data = virtual_resample)

virtual_resample_table <- get_regression_table(virtual_resample_lm)

virtual_resample_table |> 
  knitr::kable() |> 
  kableExtra::kable_styling()
```

As we saw when we did our tactile resampling exercise, @tbl-virtual-resample-lm shows that the estimated slope is different from the slope of our original sample of `r filter(resample_table, term == "mage")$estimate`. 

### **infer** package workflow

Unfortunately, our process of virtual resampling relies on us fitting a linear regression for each `rep`licate of our `virtual_resample` dataset. This gets a bit tricky coding wise, as we would need to fit 35 different linear regressions if we had 35 different resamples of our data. 

Enter, **infer**, an R package for statistical inference. **infer** makes efficient use of the `%>%` pipe operator we learned in Week 3 to spell out the sequence of steps necessary to perform statistical inference in a "tidy" and transparent fashion. Furthermore, just as the **dplyr** package provides functions with verb-like names to perform data wrangling, the **infer** package provides functions with intuitive verb-like names to perform statistical inference.

Let's go back to our original slope. Previously, we computed the value of the sample slope $b_1$ using the `lm()` function:

```{r slr-repeat}
#| eval: false
#| echo: true

births_lm <- lm(weight ~ mage, data = births14)

get_regression_table(births_lm)

```

We'll see that we can also do this using **infer** functions `specify()` and `calculate()`: 

```{r infer-slope}
#| eval: false
#| echo: true
virtual_resample %>% 
  specify(response = weight, 
          explanatory = mage) %>% 
  calculate(stat = "slope")
```

You might be asking yourself: "Isn't the **infer** code longer? Why would I use that code?". While not immediately apparent, you'll see that there are three chief benefits to the **infer** workflow as opposed to the `lm()` function workflow we had previously.

First, the **infer** verb names better align with the overall resampling framework you need to understand to construct confidence intervals and to conduct hypothesis tests. We'll see flowchart diagrams of this framework in the upcoming @fig-infer-workflow-ci.

Second, you can jump back and forth seamlessly between confidence intervals and hypothesis testing with minimal changes to your code. This will become apparent next week, when we also use **infer** to conduct hypothesis tests for the slope statistic. 

Third, the **infer** workflow is much simpler for conducting inference when you have *more than one variable*, meaning we can extend what we've learned for simple linear regression to multiple linear regression models.  

Let's now illustrate the sequence of verbs necessary to construct a confidence interval for $\b_1$, the slope of the relationship between mother's age and baby's birth weight for all US births in 2014.

#### 1. `specify()` variables {#sec-specify}

!["Diagram of `specify()`ing variables."](images/specify.png){#fig-infer-specify}

As shown in @fig-infer-specify, the `specify()` function is used to choose which variables in a data frame will be the focus of our statistical inference. We do this by `specify`ing the `response` argument. For example, in our `births14` data frame, the response variable of interest is `weight` and the explanatory variable is `mage`:

```{r}
#| echo: true
births14 %>% 
  specify(response = weight, 
          explanatory = mage)
```

Notice how the dataset got smaller, now there are only two columns where before there were `r ncol(births14)`. You should also notice the messages above the dataset (`Response: weight (numeric)` and `Explanatory: mage`). These are *meta-data* about the grouping structure of the dataset, declaring which variable has been assigned to the explanatory / response. 

::: {.callout-note}
This is similar to how the `group_by()` verb from `dplyr` doesn't change the data, but only adds "grouping" meta-data, as we saw in Week 3. 
:::

#### 2. `generate()` replicates {#sec-generate}

!["Diagram of `generate()` replicates."](images/generate.png){#fig-infer-generate}

After we `specify()` the variables of interest, we pipe the results into the `generate()` function to generate replicates. @fig-infer-generate shows how this is combined with `specify()` to start the pipeline. In other words, repeat the resampling process a large number of times, similar to how we collected 35 different samples of balls from the bowl. 

The `generate()` function's first argument is `reps`, which sets the number of replicates we would like to generate. Suppose we were interested in obtaining 50 different resamples (each of 1,000 birth records). Then, we would we set `reps = 50`, telling **infer** that we are interested in obtaining 50 different resamples, each with 1,000 observations. 

```{r}
n_virtual_resample <- 50
```

The second argument `type` determines the type of computer simulation we'd like to perform. We set this to `type = "bootstrap"` indicating that we want to perform bootstrap resampling, meaning the resampling should be done *with replacement*. You'll see different options for `type` when we learn about hypothesis testing next week.  

```{r infer-generate-code}
#| echo: true
births14 %>% 
  specify(response = weight, 
          explanatory = mage) %>% 
  generate(reps = 50, 
           type = "bootstrap")
```

Observe that the resulting data frame has `r scales::comma(nrow(births14) * n_virtual_resample)` rows. This is because we performed resampling of `r nrow(births14)` birth records with replacement `r n_virtual_resample` times and `r nrow(births14)` $\times$ `r n_virtual_resample` = `r scales::comma(nrow(births14) * n_virtual_resample)`. 

The variable `replicate` indicates which resample each row belongs to. So it has the value `1` `r nrow(births14)` times, the value `2` `r nrow(births14)` times, all the way through to the value `r n_virtual_resample` `r nrow(births14)` times. 

**Comparing with original workflow**: Note that the steps of the **infer** workflow so far produce the same results as the original workflow using the `rep_sample_n()` function we saw earlier. In other words, the following two code chunks produce similar results:

::: columns
::: {.column width="45%"}
**infer** workflow
```{r infer-vs-rep}
#| eval: false
#| echo: true
births14 %>%
  specify(response = weight, 
          explanatory = mage) %>% 
  generate(reps = 50, 
           type = "bootstrap") 
             
```
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
Original workflow

```{r rep-vs-infer}
#| eval: false
#| echo: true

rep_sample_n(births14, 
             size = 1000, 
             replace = TRUE,
             reps = 50)
```
:::
:::

#### 3. `calculate()` summary statistics {#sec-calculate}

![Diagram of calculate()d summary statistics.](images/calculate.png){#fig-calculate}

After we `generate()` many replicates of bootstrap resampling with replacement, we next want to summarize each of the `r n_virtual_resample` resamples of size `r nrow(births14)` to a single sample statistic value. As seen in @fig-calculate, the `calculate()` function does this.

In our case, we want to calculate the slope between mother's age and baby's birth weight for each bootstrap resample of size `r nrow(births14)`. To do so, we set the `stat` argument to `"slope"`. 

::: {.callout-tip}
You can also set the `stat` argument to a variety of other common summary statistics, like `"median"`, `"sum"`, `"sd"` (standard deviation), and `"prop"` (proportion). To see a list of all possible summary statistics you can use, type `?calculate` and read the help file.
:::

Let's save the result in a data frame called `bootstrap_distribution` and explore its contents:

```{r births-infer-process-code}
#| echo: true

bootstrap_distribution <- births14 %>% 
  specify(response = weight, 
          explanatory = mage) %>% 
  generate(reps = 50) %>% 
  calculate(stat = "slope")

bootstrap_distribution
```

Observe that the resulting data frame has `r n_virtual_resample` rows and two columns. The `replicate` column corresponds to the `r n_virtual_resample` replicates and the `stat` column corresponds to the estimated slope for each resample. 

#### 4. `visualize()` the results {-}

![Diagram of closing the entire process by visualize()ing the results.](images/visualize.png){#fig-visualize}

The `visualize()`verb provides a quick way to visualize the bootstrap distribution as a histogram of the numerical `stat` variable's values. The pipeline of the main **infer** verbs used for exploring bootstrap distribution results is shown in @fig-infer-visualize.  

```{r visualize-code}
#| eval: false
#| echo: true
visualize(bootstrap_distribution)
```

```{r boostrap-distribution-infer}
#| label: fig-infer-visualize
#| fig-cap: "Bootstrap distribution of slope statistics from 50 bootstrap resamples."
visualize(bootstrap_distribution) 
```

::: {.callout-tip}
The `visualize()` function can take many other arguments which we'll see momentarily to customize the plot further. It also works with helper functions to do the shading of the histogram values corresponding to the confidence interval values.
:::

**Comparing with original workflow**: In fact, `visualize()` is a *wrapper function* for the `ggplot()` function that uses a `geom_histogram()` layer. That's a lot of fancy language which means that the `visualize()` function does the **same** thing as we did previously with `ggplot()`, just with fewer steps. 


::: columns
::: {.column width="45%"}
**infer** workflow
```{r infer-vs-ggplot}
#| eval: false
#| echo: true
visualize(bootstrap_distribution)
```
:::

::: {.column width="5%"}
:::

::: {.column width="50%"}
Original workflow

```{r ggplot-vs-infer}
#| eval: false
#| echo: true
ggplot(data = bootstrap_distribution,
       mapping = aes(x = stat)) +
  geom_histogram()
```
:::
:::


::: {.callout-caution}
Careful! It might sound tempting to ditch the `ggplot()` code altogether now that you know of a simpler approach. The `visualize()` function only works for a specific case -- a data frame containing a distribution of `calculate()`d statistics. 
:::

Let's recap the steps of the **infer** workflow for constructing a bootstrap distribution and then visualizing it in @fig-infer-workflow-ci.

![infer package workflow for resampling](images/ci_diagram.png){#fig-infer-workflow-ci}

### Virtually resampling 1,000 times

To change from resampling 50 times to resampling 1,000 times, only one line of code needs to change---the number of `reps`. In the code process below, we've chained together the entire **infer** pipeline, connecting the specify, generate, calculate, and visualize steps. 

```{r entire-infer}
#| label: fig-infer-1000
#| fig-cap: "Bootstrap distribution with 1,000 replicates."
#| echo: true

bootstrap_1000 <- births14 |> 
  specify(response = weight, 
          explanatory = mage) |> 
  generate(reps = 1000, 
           type = "bootstrap") |> 
  calculate(stat = "slope") 

visualize(bootstrap_1000) + 
  labs(x = "Bootstrap Slope Statistic", 
       y = "Bootstrap Distribution of 1,000 Resamples")
```

::: {.callout-note}
# Changing axis labels

Notice you can still use the `labs()` function to change your axis labels. Notice that you still need to connect the axis labels with the plot using a `+` sign.  
:::

What do you notice about this distribution? What distribution does it resemble? Why is that the case?

### Connection to sampling distributions

The histogram of sample slopes in @fig-infer-1000 is called the **bootstrap distribution**. The bootstrap distribution is an *approximation* to the sampling distribution of sample slopes. 

If you recall back to the last chapter, a sampling distribution was a distribution of statistics from repeatedly *sampling* from the **population**. However, a bootstrap distribution is a distribution of statistics from repeatedly *resampling* from the **sample**. This may seem rather strange, how can a distribution based entirely on the sample approximate a distribution based on the population? That's a great question! 

The bootstrapping process hinges on the belief that the sample is representative of the population. Meaning, there are not systematic differences between the sample and the population. For example, if there were no young mothers in the sample of 1,000 birth records in the `births14` dataset. If we have a random sample, however, then on average our sample should look very similar to our population. Meaning, the individuals in the sample can "stand in" for individuals in the population with similar characteristics. So, we can think of repeatedly *resampling* from our sample as a similar process as sampling from the population. 

::: {.callout-caution collapse="true"}
### No guaranteed representation
The process of randomly sampling **does not** guarantee that smaller groups of observations will *always* appear in the sample. Rather, by randomly sampling from the population, on average the representation of individuals in the sample should reflect the proportion of individuals in the population. 

To me, this feels rather uncomfortable as a random sample assumes that you can generalize from the sample onto the population from which it was drawn. This means you are generalizing the observations of a few individuals onto the entire population of similar individuals. For example, if you were to collect a random sample of Cal Poly students, it is likely your sample would include very few Black students (as Cal Poly is a predominantly white institution). But, if your sample was random, statistically you could infer from your small sample of Black students onto the entire population of Black students at Cal Poly. That seems kind of iffy to me. 
:::

## Understanding confidence intervals

Let's start this section with an analogy involving fishing. Say you are trying to catch a fish. On the one hand, you could use a spear, while on the other you could use a net. Using the net will probably allow you to catch more fish! 

In the `births14` investigation, we are trying to estimate the population slope for the relationship between mother's age and baby's birth weight ($\beta_1$) for **all** babies born in the US in 2014. Think of the value of $\beta_1$ as a fish.

On the one hand, we could use the appropriate *point estimate/sample statistic* to estimate $\beta_1$, which we saw in @tbl-births-slr is the sample slope $b_1$. Based on our sample of `r nrow(births14)` birth records, the sample slope was `r filter(births_table, term == "mage")$estimate`. Think of using this value as "fishing with a spear."

What would "fishing with a net" correspond to? Look at the bootstrap distribution in @fig-infer-1000 once more. Between which values would you say that "most" sample slopes lie?  While this question is somewhat subjective, saying that most sample slopes lie between 0 and 0.03 would not be unreasonable. Think of this interval as the "net."

What we've just illustrated is the concept of a *confidence interval*, which I'll abbreviate with "CI" throughout this chapter. As opposed to a point estimate / sample statistic that estimates the value of an unknown population parameter with a single value, a *confidence interval* gives what can be interpreted as a range of plausible values. Going back to our analogy, point estimates / sample statistics can be thought of as spears, whereas confidence intervals can be thought of as nets. 

![Analogy of difference between point estimates and confidence intervals.](images/point_estimate_vs_conf_int.png){#fig-spear-net}

Our proposed interval of 0 to 0.03 was constructed by eye and was thus somewhat subjective. We now introduce two methods for constructing such intervals in a more exact fashion: the *percentile method* and the *standard error method*.

Both methods for confidence interval construction share some commonalities. First, they are both constructed from a bootstrap distribution, as you constructed in the previous section and visualized in @fig-infer-1000.

Second, they both require you to specify the *confidence level*. Commonly used confidence levels include 90%, 95%, and 99%.  All other things being equal, higher confidence levels correspond to wider confidence intervals, and lower confidence levels correspond to narrower confidence intervals. 

```{r bootstrap-1000-percentile-interval}
percentile_ci <- get_confidence_interval(bootstrap_1000, level = 0.95)
```


### Percentile method {#sec-percentile-method}

One method to construct a 95% confidence interval is to use the middle 95% of values of the bootstrap distribution. We can do this by computing the 2.5th and 97.5th percentiles, which are `r round(percentile_ci[["lower_ci"]], digits = 4)` and `r round(percentile_ci[["upper_ci"]], digits = 4)`, respectively. This is known as the *percentile method* for constructing confidence intervals. 

For now, let's focus only on the concepts behind a percentile method constructed confidence interval; we'll show you the code that computes these values in the next section.

Let's mark these percentiles on the bootstrap distribution with vertical lines in @fig-percentile-method. About 95% of the `slope` variable values in `bootstrap_1000` fall between `r round(percentile_ci[["lower_ci"]], digits = 4)` and `r round(percentile_ci[["upper_ci"]], digits = 4)`, with 2.5% to the left of the leftmost line and 2.5% to the right of the rightmost line. 

```{r percentile-method-CI}
#| label: fig-percentile-method
#| fig-cap: "Percentile method 95% confidence interval. Interval endpoints marked by vertical lines." 

ggplot(bootstrap_1000, aes(x = stat)) +
  geom_histogram(binwidth = 0.005, color = "white") +
  labs(x = "Resample sample slope statistics") + 
  geom_vline(xintercept = percentile_ci[[1, 1]], linewidth = 1.5, color = "blue") +
  geom_vline(xintercept = percentile_ci[[1, 2]], linewidth = 1.5, color = "blue")
```

### Standard error method {#se-method}

```{r bootstrap-1000-se-interval}
obs_slope <- births14 %>% 
  specify(response = weight, 
          explanatory = mage) %>% 
  calculate(stat = "slope") %>% 
  pull(stat)
  
  
standard_error_ci <- bootstrap_1000 %>% 
  get_confidence_interval(type = "se", 
                          point_estimate = obs_slope, 
                          level = 0.95)

bootstrap_se <- bootstrap_1000 %>%
  summarize(se = sd(stat)) %>%
  pull(se)
```

Recall in the last chapter we saw that if a numerical variable follows a normal distribution, or, in other words, the histogram of this variable is bell-shaped, then roughly 95% of values fall between $\pm$ `r qnorm(0.975) %>% round(2)` standard deviations of the mean. Given that our bootstrap distribution based on `r nrow(bootstrap_1000)` resamples with replacement in @fig-infer-1000 is normally shaped, let's use this fact about normal distributions to construct a confidence interval in a different way.

First, recall the bootstrap distribution has a mean equal to `r mean(bootstrap_1000$stat) %>% round(3)`. This value almost coincides exactly with the value of the sample slope $b_1$ of our original `r nrow(births14)` birth records `r filter(births_table, term == "mage")$estimate`. Second, let's compute the standard deviation of the bootstrap distribution using the bootstrap slope statistics stored in the `stat` column of the `bootstrap_1000` data frame:

```{r}
#| echo: true
bootstrap_1000 %>% 
  summarize(SE = sd(stat))
```

What is this value? Recall that the bootstrap distribution is an approximation to the sampling distribution. Thus, the variability of the sampling distribution may be approximated by the variability of the resampling distribution. Recall also that the standard deviation of a sampling distribution has a special name: the *standard error*. Putting these two facts together, we can say that `r bootstrap_se %>% round(5)` is an approximation of the standard error of $b_1$.  

Traditional theory-based methodologies for inference also have formulas for standard errors, assuming some conditions are not violated. In this method, we are not using a formula to get our standard error, but using the standard error of the bootstrap distribution. Thus, using our 95% rule of thumb about normal distributions, we can use the following formula to determine the lower and upper endpoints of a 95% confidence interval for $\beta_1$:

$$
b_1 \pm `r qnorm(0.975) %>% round(2)` \times SE = (b_1 - `r qnorm(0.975) %>% round(2)` \times SE, b_1 + `r qnorm(0.975) %>% round(2)` \times SE)
$$

$$= (`r filter(births_table, term == "mage")$estimate` - `r qnorm(0.975) %>% round(2)` \times `r bootstrap_se %>% round(3)`, `r filter(births_table, term == "mage")$estimate` + `r qnorm(0.975) %>% round(2)` \times `r bootstrap_se %>% round(3)`)
$$

$$= (`r filter(births_table, term == "mage")$estimate  - (qnorm(0.975) %>% round(2) * bootstrap_se %>% round(3))`, `r filter(births_table, term == "mage")$estimate + (qnorm(0.975) %>% round(2) * bootstrap_se %>% round(3))`)
$$

::: {.callout-note}
To use the bootstrap standard error in this formula the bootstrap distribution **must** be bell shaped and symmetric. This is often the case with bootstrap distributions, especially those in which the original distribution of the sample is not highly skewed, however it is not always the case. Next week, we'll go deeper into the explorations of model conditions. 
:::

Let's now add the SE method confidence interval with dashed lines in @fig-percentile-and-se-method.

```{r percentile-and-se-method}
#| label: fig-percentile-and-se-method 
#| fig-cap: "Comparing two 95% confidence interval methods."

both_CI <- bind_rows(
  # long percentile CI
  percentile_ci %>% 
  pivot_longer(cols = everything(), 
               names_to = "endpoint", 
               values_to = "value") %>% 
  mutate(type = "percentile"), 
  # long SE CI
  standard_error_ci %>%
  pivot_longer(cols = everything(), 
               names_to = "endpoint", 
               values_to = "value") %>% 
  mutate(type = "SE")
)

ggplot(data = bootstrap_1000, 
       mapping = aes(x = stat)) +
  geom_histogram(binwidth = 0.005, color = "white") +
  labs(x = "Bootstrap Slope Statistic", 
       title = "Percentile method CI (solid green lines) \n SE method CI (dashed blue lines)") +
  geom_vline(xintercept = percentile_ci[[1, 1]], 
             linewidth = 1, 
             color = "darkgreen") +
  geom_vline(xintercept = percentile_ci[[1, 2]], 
             linewidth = 1, 
             color = "darkgreen") +
  geom_vline(xintercept = standard_error_ci[[1, 1]], 
             linetype = "dashed", 
             linewidth = 1, 
             color = "blue") +
  geom_vline(xintercept = standard_error_ci[[1, 2]], 
             linetype = "dashed", 
             linewidth = 1, 
             color = "blue")
```

We see that both methods produce nearly identical 95% confidence intervals for $\beta_1$ with the percentile method yielding $(`r round(percentile_ci[["lower_ci"]], 4)`, `r round(percentile_ci[["upper_ci"]], 4)`)$ while the standard error method produces $(`r round(standard_error_ci[["lower_ci"]], 4)`, `r round(standard_error_ci[["upper_ci"]], 4)`)$. 

Now that we've introduced the concept of confidence intervals and laid out the intuition behind two methods for constructing them, let's explore the code that allows us to construct them. 


## Constructing confidence intervals

Recall how we introduced two different methods for constructing 95% confidence intervals for an unknown population parameter in Section \@ref(ci-build-up): the *percentile method* and the *standard error method*. Let's now check out the **infer** package code that explicitly constructs these. There are also some additional neat functions to visualize the resulting confidence intervals built-in to the **infer** package!

#### Percentile method with **infer**

#### Standard error method with **infer**


These are automatically calculated when `level` is provided with `level = 0.95` being the default. (95% of the values in a standard normal distribution fall within `r qnorm(0.975) %>% round(2)` standard deviations of the mean, so $multiplier = `r qnorm(0.975) %>% round(2)`$ for `level = 0.95`, for example.) 

This $\bar{x} \pm (multiplier * SE)$ formula is implemented in the `get_confidence_interval()` function as shown with our pennies problem using the bootstrap distribution's variability as an approximation for the sampling distribution's variability. We'll see more on this approximation shortly.
Note that the center of the confidence interval (the `point_estimate`) must be provided for the standard error confidence interval.


## Interpreting confidence intervals

### Did the net capture the fish?

### Precise and shorthand interpretation

### Withd of confidence intervals
